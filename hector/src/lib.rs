use axum::{
    Router,
    body::Body,
    http::{StatusCode, header},
    response::Response,
    routing::get,
};

/// Returns an axum `Router` that serves the embedded source tarball at `GET /hector`.
///
/// The response is a `application/gzip` download (`sources.tar.gz`).
/// Pass the tarball bytes produced by the [`sources!`] macro:
/// ```rust,ignore
/// let app = Router::new().merge(hector::router(hector::sources!()));
/// ```
pub fn router(tarball: &'static [u8]) -> Router {
    Router::new().route("/hector", get(move || handler(tarball)))
}

async fn handler(tarball: &'static [u8]) -> Response {
    Response::builder()
        .status(StatusCode::OK)
        .header(header::CONTENT_TYPE, "application/gzip")
        .header(
            header::CONTENT_DISPOSITION,
            "attachment; filename=\"sources.tar.gz\"",
        )
        .body(Body::from(tarball))
        .unwrap()
}

/// Expands to the `HECTOR_TARBALL` static byte slice generated by `hector-build`
/// at compile time. Use this to pass the tarball to [`router`].
///
/// # Example
/// ```rust,ignore
/// hector::router(hector::sources!())
/// ```
#[macro_export]
macro_rules! sources {
    () => {
        include_bytes!(concat!(env!("OUT_DIR"), "/hector_sources.tar.gz"))
    };
}
